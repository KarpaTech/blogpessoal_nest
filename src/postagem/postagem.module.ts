import { Module } from '@nestjs/common'; //Importamos o pacote Common com os respectivos decoradores, utilizados na implementação da Classe PostagemModule. O Common contém utilitários essenciais para o NestJS, como Module, Injectable, entre outros, que são utilizados para configurar as funcionalidades principais do módulo
import { TypeOrmModule } from '@nestjs/typeorm'; //Importamos o pacote TypeORM com os respectivos decoradores, que são utilizados para trabalhar com o banco de dados. Esses decoradores ajudam a mapear as entidades e relacionamentos para a criação de tabelas e a interação com o banco de dados
import { Postagem } from './entities/postagem.entity'; // Importamos a Classe Postagem, que foi criada anteriormente. Observe que, para garantir boas práticas de organização e manutenção do código, estamos utilizando o caminho relativo (./entities/postagem.entity.ts) ao invés do caminho absoluto (src/entities/postagem.entity.ts). Usar caminhos relativos ajuda a tornar o código mais modular e independente de estruturas específicas de diretórios, facilitando refatorações e migrações de código sem a necessidade de atualizar diversos caminhos de importação
import { PostagemService } from './services/postagem.service';
import { PostagemController } from './controllers/postagem.controller';

@Module({
  //O decorador @Module define que esta classe será a principal do Módulo. Nela, registramos todas as dependências necessárias, como as Classes Entidade, Service e Controller, que fazem parte do módulo. Este decorador organiza a estrutura do módulo, tornando as classes do módulo acessíveis ao NestJS
  imports: [TypeOrmModule.forFeature([Postagem])], //No array imports, utilizamos o método forFeature() da classe TypeOrmModule para importar todas as Classes Entidade (Model) do módulo. Este método é responsável por registrar as entidades, permitindo que o NestJS as utilize para interagir com o banco de dados. No caso, estamos importando a Classe Entidade Postagem para associá-la à tabela tb_postagens.
  providers: [PostagemService], //No array providers, registramos todas as Classes de Serviço que serão responsáveis pela lógica da aplicação. Como ainda não implementamos nenhum serviço, deixamos esse array vazio, mas futuramente vamos adicionar a Classe PostagemService para gerenciar as operações CRUD da tabela tb_postagens.
  controllers: [PostagemController], //No array controllers, registramos todas as Classes Controladoras, que são responsáveis por receber as requisições HTTP (requests) e delegar o processamento para as classes de serviço. No momento, o array está vazio, já que ainda não implementamos a Classe PostagemController
  exports: [], //No array exports, adicionamos as Classes que precisam ser disponibilizadas para outros módulos. Isso permite que outras partes da aplicação possam utilizar essas classes de forma compartilhada
})
export class PostagemModule {} //A classe PostagemModule é exportada, tornando-a acessível e permitindo que ela seja registrada no AppModule. O AppModule é o módulo raiz da aplicação e, ao registrar o PostagemModule, ele disponibiliza as funcionalidades de postagem para toda a aplicação
